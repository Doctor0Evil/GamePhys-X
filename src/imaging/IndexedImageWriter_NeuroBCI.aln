#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <string>
#include <fstream>
#include <stdexcept>
#include <algorithm>
#include <memory>
#include <cstring>

// If you link libpng, include it here:
#include <png.h>

namespace NeuroImaging
{
    // Pixel formats
    enum class PixelFormat : uint8_t
    {
        RGBA8888 = 0,
        INDEXED8 = 1
    };

    struct Pixmap
    {
        uint32_t width  = 0;
        uint32_t height = 0;
        PixelFormat format = PixelFormat::RGBA8888;
        uint8_t* data = nullptr;      // RGBA or 8-bit indices depending on format
        uint32_t strideBytes = 0;     // bytes per row

        bool valid() const
        {
            return data && width > 0 && height > 0 && strideBytes > 0;
        }
    };

    struct RGBColor
    {
        uint8_t r = 0;
        uint8_t g = 0;
        uint8_t b = 0;
    };

    class IndexedPixmap
    {
    public:
        IndexedPixmap(uint32_t w, uint32_t h)
        : m_Width(w)
        , m_Height(h)
        , m_Data(w * h, 0)
        {}

        uint32_t width()  const { return m_Width;  }
        uint32_t height() const { return m_Height; }

        void writePixel(uint32_t x, uint32_t y, uint8_t index)
        {
            if (x >= m_Width || y >= m_Height) return;
            m_Data[y * m_Width + x] = index;
        }

        uint8_t* rowPtr(uint32_t y)
        {
            if (y >= m_Height) return nullptr;
            return m_Data.data() + y * m_Width;
        }

    private:
        uint32_t            m_Width;
        uint32_t            m_Height;
        std::vector<uint8_t> m_Data;
    };

    class IndexedImageWriter
    {
    public:
        IndexedImageWriter()
        {
            loadDefaultPalette();
        }

        // --------------------------------------------------------------------
        // Load palette: 256 * 3 bytes from stream (R,G,B) into internal table
        // Integrate with your engineâ€™s IO; here a simple std::istream is used.
        // --------------------------------------------------------------------
        void loadPaletteFromStream(std::istream& in)
        {
            for (int i = 0; i < 256; ++i)
            {
                uint8_t r = 0, g = 0, b = 0;
                if (!in.read(reinterpret_cast<char*>(&r), 1)) throw std::runtime_error("Palette truncated (R)");
                if (!in.read(reinterpret_cast<char*>(&g), 1)) throw std::runtime_error("Palette truncated (G)");
                if (!in.read(reinterpret_cast<char*>(&b), 1)) throw std::runtime_error("Palette truncated (B)");
                m_Palette[i].r = r;
                m_Palette[i].g = g;
                m_Palette[i].b = b;
            }
        }

        // If you want a baked-in grayscale palette instead of external file:
        void loadDefaultPalette()
        {
            for (int i = 0; i < 256; ++i)
            {
                m_Palette[i].r = static_cast<uint8_t>(i);
                m_Palette[i].g = static_cast<uint8_t>(i);
                m_Palette[i].b = static_cast<uint8_t>(i);
            }
        }

        // --------------------------------------------------------------------
        // Convert a 32-bit RGB or RGBA pixel (0xAARRGGBB or 0xRRGGBB) to
        // closest palette index by squared Euclidean distance in RGB space.
        // Special-case mapping:
        //  - pure magenta (255,0,255) -> index 0 (mask)
        //  - black (0,0,0)            -> index 245
        //  - white (255,255,255)      -> index 254
        // --------------------------------------------------------------------
        uint8_t convertColorToClosestIndex(uint32_t pixel) const
        {
            uint8_t r = static_cast<uint8_t>((pixel >> 16) & 0xFF);
            uint8_t g = static_cast<uint8_t>((pixel >> 8)  & 0xFF);
            uint8_t b = static_cast<uint8_t>(pixel & 0xFF);

            if (r == 255 && g == 0   && b == 255) return 0;   // magenta
            if (r == 0   && g == 0   && b == 0)   return 245; // black
            if (r == 255 && g == 255 && b == 255) return 254; // white

            int bestIndex    = 0;
            int bestDistance = 17000000; // > 255^2 * 3

            for (int i = 0; i < 256; ++i)
            {
                int dr = static_cast<int>(r) - m_Palette[i].r;
                int dg = static_cast<int>(g) - m_Palette[i].g;
                int db = static_cast<int>(b) - m_Palette[i].b;
                int dist = dr * dr + dg * dg + db * db;
                if (dist <= bestDistance)
                {
                    bestDistance = dist;
                    bestIndex = i;
                }
            }
            return static_cast<uint8_t>(bestIndex);
        }

        // --------------------------------------------------------------------
        // BMP writer: 8bpp indexed BMP with 256-color palette.
        // Writes BMPv3 header, palette, and padded pixel rows (bottom-up).
        // --------------------------------------------------------------------
        bool writeIndexedBMPFromPixmap(const Pixmap& src, const std::string& filename)
        {
            if (!src.valid() || filename.empty())
                return false;

            uint32_t bmpWidth  = src.width;
            uint32_t bmpHeight = src.height;

            uint32_t bmpWidthM4 = ((bmpWidth + 3u) / 4u) * 4u;
            uint32_t headerSize = 14u + 40u;
            uint32_t colorTableSize = 256u * 4u;
            uint32_t pixelArraySize = bmpWidthM4 * bmpHeight;
            uint32_t bmpSizeTotal   = headerSize + colorTableSize + pixelArraySize;
            uint32_t bmpSizeTotalM4 = ((bmpSizeTotal + 3u) / 4u) * 4u;

            std::ofstream out(filename, std::ios::binary);
            if (!out.is_open())
                return false;

            // Little-endian helpers
            auto writeU16 = [&](uint16_t v)
            {
                out.put(static_cast<char>(v & 0xFF));
                out.put(static_cast<char>((v >> 8) & 0xFF));
            };
            auto writeU32 = [&](uint32_t v)
            {
                out.put(static_cast<char>( v        & 0xFF));
                out.put(static_cast<char>((v >> 8)  & 0xFF));
                out.put(static_cast<char>((v >> 16) & 0xFF));
                out.put(static_cast<char>((v >> 24) & 0xFF));
            };

            // Bitmap File Header
            writeU16(0x4D42);                 // 'BM'
            writeU32(bmpSizeTotalM4);         // File size
            writeU32(0);                      // Reserved
            writeU32(14u + 40u + 256u * 4u);  // Pixel data offset

            // DIB Header
            writeU32(40u);                    // DIB header size
            writeU32(bmpWidth);               // width
            writeU32(bmpHeight);              // height
            writeU16(1u);                     // planes
            writeU16(8u);                     // bpp
            writeU32(0u);                     // compression BI_RGB
            writeU32(pixelArraySize);         // image size
            writeU32(2835u);                  // X ppm (~72 DPI)
            writeU32(2835u);                  // Y ppm (~72 DPI)
            writeU32(256u);                   // colors in table
            writeU32(0u);                     // important colors

            // Color table: BGRA per entry
            for (int i = 0; i < 256; ++i)
            {
                out.put(static_cast<char>(m_Palette[i].b));
                out.put(static_cast<char>(m_Palette[i].g));
                out.put(static_cast<char>(m_Palette[i].r));
                out.put(static_cast<char>(0)); // reserved / alpha
            }

            // Pixel array: bottom-up, padded width
            for (int y = static_cast<int>(bmpHeight) - 1; y >= 0; --y)
            {
                const uint8_t* row = src.data + static_cast<size_t>(y) * src.strideBytes;

                for (uint32_t x = 0; x < bmpWidthM4; ++x)
                {
                    if (x < bmpWidth)
                    {
                        uint32_t pixel = 0;
                        if (src.format == PixelFormat::RGBA8888)
                        {
                            const uint8_t* p = row + x * 4;
                            uint8_t r = p[0];
                            uint8_t g = p[1];
                            uint8_t b = p[2];
                            pixel = (static_cast<uint32_t>(r) << 16) |
                                    (static_cast<uint32_t>(g) << 8)  |
                                    static_cast<uint32_t>(b);
                        }
                        else
                        {
                            // If already indexed, treat palette index as grayscale,
                            // or adjust to your specific needs.
                            uint8_t idx = row[x];
                            const RGBColor& c = m_Palette[idx];
                            pixel = (static_cast<uint32_t>(c.r) << 16) |
                                    (static_cast<uint32_t>(c.g) << 8)  |
                                    static_cast<uint32_t>(c.b);
                        }
                        uint8_t idx = convertColorToClosestIndex(pixel);
                        out.put(static_cast<char>(idx));
                    }
                    else
                    {
                        out.put(static_cast<char>(0)); // padding
                    }
                }
            }

            // EOF padding
            uint32_t padding = bmpSizeTotalM4 - bmpSizeTotal;
            for (uint32_t i = 0; i < padding; ++i)
                out.put(static_cast<char>(0));

            return true;
        }

        // --------------------------------------------------------------------
        // PNG writer: 8bpp indexed PNG via libpng.
        // Converts RGBA8888 pixmap into an 8bpp index buffer, then writes.
        // compressionLevel: 0..9
        // --------------------------------------------------------------------
        bool writeIndexedPNGFromPixmap(const Pixmap& src,
                                       const std::string& filename,
                                       int compressionLevel = 5)
        {
            if (!src.valid() || filename.empty())
                return false;

            FILE* fp = std::fopen(filename.c_str(), "wb");
            if (!fp)
                return false;

            png_structp pngPtr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
                                                         nullptr,
                                                         nullptr,
                                                         nullptr);
            if (!pngPtr)
            {
                std::fclose(fp);
                return false;
            }

            png_infop infoPtr = png_create_info_struct(pngPtr);
            if (!infoPtr)
            {
                png_destroy_write_struct(&pngPtr, nullptr);
                std::fclose(fp);
                return false;
            }

            if (setjmp(png_jmpbuf(pngPtr)))
            {
                png_destroy_write_struct(&pngPtr, &infoPtr);
                std::fclose(fp);
                return false;
            }

            png_init_io(pngPtr, fp);
            png_set_compression_level(pngPtr,
                                      std::max(0, std::min(compressionLevel, 9)));

            png_set_IHDR(
                pngPtr,
                infoPtr,
                src.width,
                src.height,
                8,
                PNG_COLOR_TYPE_PALETTE,
                PNG_INTERLACE_NONE,
                PNG_COMPRESSION_TYPE_DEFAULT,
                PNG_FILTER_TYPE_DEFAULT);

            std::array<png_color, 256> pngPalette{};
            for (int i = 0; i < 256; ++i)
            {
                pngPalette[i].red   = m_Palette[i].r;
                pngPalette[i].green = m_Palette[i].g;
                pngPalette[i].blue  = m_Palette[i].b;
            }
            png_set_PLTE(pngPtr, infoPtr, pngPalette.data(), 256);

            IndexedPixmap idxPx(src.width, src.height);

            for (uint32_t y = 0; y < src.height; ++y)
            {
                const uint8_t* row = src.data + static_cast<size_t>(y) * src.strideBytes;
                for (uint32_t x = 0; x < src.width; ++x)
                {
                    uint32_t pixel = 0;
                    if (src.format == PixelFormat::RGBA8888)
                    {
                        const uint8_t* p = row + x * 4;
                        uint8_t r = p[0];
                        uint8_t g = p[1];
                        uint8_t b = p[2];
                        pixel = (static_cast<uint32_t>(r) << 16) |
                                (static_cast<uint32_t>(g) << 8)  |
                                static_cast<uint32_t>(b);
                    }
                    else
                    {
                        uint8_t idx = row[x];
                        const RGBColor& c = m_Palette[idx];
                        pixel = (static_cast<uint32_t>(c.r) << 16) |
                                (static_cast<uint32_t>(c.g) << 8)  |
                                static_cast<uint32_t>(c.b);
                    }
                    uint8_t index = convertColorToClosestIndex(pixel);
                    idxPx.writePixel(x, y, index);
                }
            }

            std::vector<png_bytep> rows(src.height);
            for (uint32_t y = 0; y < src.height; ++y)
                rows[y] = idxPx.rowPtr(y);

            png_set_rows(pngPtr, infoPtr, rows.data());
            png_write_png(pngPtr, infoPtr, PNG_TRANSFORM_IDENTITY, nullptr);

            png_destroy_write_struct(&pngPtr, &infoPtr);
            std::fclose(fp);
            return true;
        }

    private:
        std::array<RGBColor, 256> m_Palette;
    };
}
